
export type GameBoardChunk = {
  readonly index: number;
  readonly face: IcosphereFace;
  readonly faceCoords: {
    readonly a: Vector2;
    readonly b: Vector2;
    readonly c: Vector2;
  };
};


    let index = 0;
    for (let f = 0; f < icosahedron.faces.length; f++) {
      const face = icosahedron.faces[f];
      for (let y = 0; y < this.resolution + 1; y++) {
        // noinspection PointlessArithmeticExpressionJS
        for (let x = y + 0; x < this.resolution + 1; x++) {
          const p00 = new Vector2(
            x / (this.resolution + 1.0),
            y / (this.resolution + 1.0),
          );
          const p10 = new Vector2(
            (x + 1.0) / (this.resolution + 1.0),
            y / (this.resolution + 1.0),
          );
          const p11 = new Vector2(
            (x + 1) / (this.resolution + 1.0),
            (y + 1) / (this.resolution + 1.0),
          );
          const mod = index % 3;
          this.tris.push({
            index: index++,
            face,
            faceCoords:
              mod === 0
                ? { a: p00, b: p10, c: p11 }
                : mod === 1
                  ? { a: p11, b: p00, c: p10 }
                  : { a: p10, b: p11, c: p00 },
          });
        }
        for (let x = y + 1; x < this.resolution + 1; x++) {
          const p00 = new Vector2(
            x / (this.resolution + 1.0),
            y / (this.resolution + 1.0),
          );
          const p01 = new Vector2(
            x / (this.resolution + 1.0),
            (y + 1.0) / (this.resolution + 1.0),
          );
          const p11 = new Vector2(
            (x + 1.0) / (this.resolution + 1.0),
            (y + 1.0) / (this.resolution + 1.0),
          );
          const mod = index % 3;
          this.tris.push({
            index: index++,
            face,
            faceCoords:
              mod === 0
                ? { a: p11, b: p01, c: p00 }
                : mod === 1
                  ? { a: p00, b: p11, c: p01 }
                  : { a: p01, b: p00, c: p11 },
          });
        }
      }
    }

  //----------------------------------------------------------------------------

  /*
  private readonly createConnections = () => {
    for (let edgeIndex = 0; edgeIndex < 30; edgeIndex++) {
      for (let i = 1; i < (this.resolution + 1) * 5; i++) {
        const index =
            12 + edgeIndex * ((this.resolution + 1) * 5 - 1) + (i - 1);
        const start = i === 1 ? null : this.tiles[index];
        const end =
            i === (this.resolution + 1) * 5 - 1 ? null : this.tiles[index + 1];
        if (!!start && !!end) this.connections.push({ index, start, end });
      }
    }
  };

  private readonly addNeighbor = (
    tile: GameBoardTile,
    i: number,
    j: number,
  ) => {
    const neighbor = this.getFaceTile(tile.face.index, i, j);
    return tile.neighbors.push(neighbor);
  };

  private readonly stitchFaceTiles = (face: IcosphereFace) => {
    for (let i = 0; i < (this.resolution + 1) * 5 - 1; i++) {
      const isAtMinI = i === 0;
      const isAtMaxI = i === (this.resolution + 1) * 5 - 2;
      for (let j = 0; j < i - 1; j++) {
        const isAtMinJ = j === 0;
        const isAtMaxJ = j === i - 1;
        const tile = this.getFaceTile(face.index, i, j);
        if (!isAtMinI) {
          this.addNeighbor(tile, i - 1, j);
          if (!isAtMinJ) this.addNeighbor(tile, i - 1, j - 1);
        }
        if (!isAtMinJ) this.addNeighbor(tile, i, j - 1);
        if (!isAtMaxI) {
          this.addNeighbor(tile, i + 1, j);
          if (!isAtMaxJ) this.addNeighbor(tile, i + 1, j + 1);
        }
        if (!isAtMaxI) this.addNeighbor(tile, i, j + 1);
      }
    }
  };
  */